\section{Miscellaneous}
\label{sec:misc}
Features/Phenomenon which didn't fit into any other category.


\subsection{Influence of movement keys}
\label{sec:movementkeys}
\begin{align*}
\vec{\cmd} =
\begin{pmatrix}
\fmove \\ \rmove \\ \umove
\end{pmatrix}, \qquad \vec{\flat{\cmd}} =
\begin{pmatrix}
\fmove \\ \rmove \\ 0
\end{pmatrix},
\end{align*}
The direction of acceleration $\uvec{\flat{a}}$ \eqref{eq:accel_direction} can be chosen by using your mouse and the movement keys. Relative to $\nu = \atan\left(\frac{v_y}{v_x}\right)$
\begin{align*}
\uvec{\flat{v}} = \frac{1}{\flat{v}}
\begin{pmatrix}
v_x \\ v_y \\ 0
\end{pmatrix}
\end{align*}

\begin{figure}[H]
	\centering
	\begin{subfigure}[t]{.5\textwidth}
		\centering
		\setlength\figureheight{5.5cm}
		\setlength\figurewidth{5.5cm}
		\includetikz{tikz/cmd}
		\caption{}
	\end{subfigure}%
	\begin{subfigure}[t]{.5\textwidth}
		\centering
		\setlength\figureheight{5.5cm}
		\setlength\figurewidth{5.5cm}
		\includetikz{tikz/cmd3d} % TODO: merge cmd3d_2
		\caption{}
	\end{subfigure}%
	\caption{The current velocity $\vec{\flat{v}}_f$ (\yellowarrow), the acceleration $\vec{a}$ (\orangearrow) and the resulting new velocity $\vec{\flat{r}}$ (\bluearrow). (a) is the top view of (b). key plane (\lightorangearea). $\theta = \atan\sqrt{2}$}
	\label{fig:cmd}
\end{figure}

% TODO: make projections of 2 vs 1 key combinations

where $\gamma = \delta + \nu$ represents the yaw angle.

Appendix \ref{app:angle_vectors}

The current velocity vector is defined as
\begin{align*}
\uvec{\fmove} &=
\begin{pmatrix}
	\cos\rho\cos\gamma\\
	\cos\rho\sin\gamma\\
	-\sin\rho
\end{pmatrix},\\
\uvec{\rmove} &=
\begin{pmatrix}
	-\sin\sigma\sin\rho\cos\gamma + \cos\sigma\sin\gamma\\
	-\sin\sigma\sin\rho\sin\gamma - \cos\sigma\cos\gamma\\
	-\sin\sigma\cos\rho
\end{pmatrix},\\
\uvec{\umove} &=
\begin{pmatrix}
	\cos\sigma\sin\rho\cos\gamma + \sin\sigma\sin\gamma\\
	\cos\sigma\sin\rho\sin\gamma - \sin\sigma\cos\gamma\\
	\cos\sigma\cos\rho
\end{pmatrix},
\end{align*}

\codeFromFile{firstline=621,lastline=625,gobble=1}{code/game/bg_pmove.c}

\begin{align*}
\uvec{\flat{\fmove}} &=
\begin{pmatrix}
	\cos\rho\cos\gamma\\
	\cos\rho\sin\gamma\\
	0
\end{pmatrix} \frac{1}{\sqrt{\cos^2\rho}} =
\begin{pmatrix}
	\cos\gamma\\
	\sin\gamma\\
	0
\end{pmatrix},\\
\uvec{\flat{\rmove}} &=
\begin{pmatrix}
	-\sin\sigma\sin\rho\cos\gamma + \cos\sigma\sin\gamma\\
	-\sin\sigma\sin\rho\sin\gamma - \cos\sigma\cos\gamma\\
	0
\end{pmatrix} \frac{1}{\sqrt{\sin^2\sigma\sin^2\rho + \cos^2\sigma}},
\end{align*}

\begin{align*}
\uvec{\flat{\fmove}}^T \uvec{\flat{\rmove}} &= \frac{-\sin\sigma\sin\rho\cos^2\gamma + \cos\sigma\sin\gamma\cos\gamma - \sin\sigma\sin\rho\sin^2\gamma - \cos\sigma\sin\gamma\cos\gamma}{\sqrt{\sin^2\sigma\sin^2\rho + \cos^2\sigma}}\\
&= \frac{-\sin\sigma\sin\rho}{\sqrt{\sin^2\sigma\sin^2\rho + \cos^2\sigma}}
\end{align*}

\begin{align*}
\vec{\flat{\fmove}} + \vec{\flat{\rmove}} = \texttt{wishvel} &= \fmove
\begin{pmatrix}
	\cos\gamma\\
	\sin\gamma\\
	0
\end{pmatrix} + \rmove
\begin{pmatrix}
	-\sin\sigma\sin\rho\cos\gamma + \cos\sigma\sin\gamma\\
	-\sin\sigma\sin\rho\sin\gamma - \cos\sigma\cos\gamma\\
	0
\end{pmatrix} \frac{1}{\sqrt{\sin^2\sigma\sin^2\rho + \cos^2\sigma}},
\end{align*}

\begin{align*}
\norm*{\vec{\flat{\fmove}} + \vec{\flat{\rmove}}}^2 = \norm{\texttt{wishvel}}^2 = &\fmove^2 \cos^2\gamma + \rmove^2 \frac{\sin^2\sigma\sin^2\rho\cos^2\gamma + \cos^2\sigma\sin^2\gamma - \sin\sigma\cos\sigma\sin\rho\sin\gamma\cos\gamma}{\sin^2\sigma\sin^2\rho + \cos^2\sigma} +\\
&\fmove^2 \sin^2\gamma + \rmove^2 \frac{\sin^2\sigma\sin^2\rho\sin^2\gamma + \cos^2\sigma\cos^2\gamma + \sin\sigma\cos\sigma\sin\rho\sin\gamma\cos\gamma}{\sin^2\sigma\sin^2\rho + \cos^2\sigma} +\\
&2\fmove\rmove\frac{-\sin\sigma\sin\rho\cos^2\gamma + \cos\sigma\sin\gamma\cos\gamma}{\sqrt{\sin^2\sigma\sin^2\rho + \cos^2\sigma}} +\\
&2\fmove\rmove\frac{-\sin\sigma\sin\rho\sin^2\gamma - \cos\sigma\sin\gamma\cos\gamma}{\sqrt{\sin^2\sigma\sin^2\rho + \cos^2\sigma}},\\
%
= &\fmove^2 + \rmove^2 + 2\fmove\rmove\frac{-\sin\sigma\sin\rho}{\sqrt{\sin^2\sigma\sin^2\rho + \cos^2\sigma}},
\end{align*}

Derivative
\begin{align*}
\frac{\mathrm{d}}{\mathrm{d}\rho} \norm*{\vec{\flat{\fmove}} + \vec{\flat{\rmove}}}^2 = \frac{\mathrm{d}}{\mathrm{d}\rho} \norm{\texttt{wishvel}}^2 = 2\fmove\rmove\frac{-\sin\sigma\cos^2\sigma\cos\rho}{\left( \sin^2\sigma\sin^2\rho + \cos^2\sigma \right)^{3/2}},
\end{align*}
This is $0$ when
\[
\begin{cases}
	\rho = \hphantom{-}\frac{\pi}{2} + 2k\pi, &k \in \symbb{N},\\
	\rho = -\frac{\pi}{2} + 2k\pi, &k \in \symbb{N}.
\end{cases}
\]

With optimal $\rho$ filled in, we get
\begin{align*}
\uvec{\flat{\fmove}}^T \uvec{\flat{\rmove}} &= -\sin\sigma,\\
&= \sin\sigma,
\end{align*}
\begin{align*}
\norm*{\vec{\flat{\fmove}} + \vec{\flat{\rmove}}}^2 = \norm{\texttt{wishvel}}^2 &= \fmove^2 + \rmove^2 - 2\fmove\rmove\sin\sigma,\\
&= \fmove^2 + \rmove^2 + 2\fmove\rmove\sin\sigma,
\end{align*}

Appendix \ref{app:cmd_scale}

\begin{align*}
\texttt{scale} = \frac{\texttt{speed}\norm{\vec{\cmd}}_{\infty}}{127\norm{\vec{\cmd}}},
\end{align*}

\begin{align*}
\texttt{wishspeed} &= \texttt{scale} \norm{\texttt{wishvel}} =
\frac{\texttt{speed}\norm{\vec{\cmd}}_{\infty}}{127\norm{\vec{\cmd}}} \norm{\texttt{wishvel}},\\
\norm*{\vec{\flat{a}}} &= \flat{a} = AT \texttt{wishspeed} = AT\frac{\texttt{speed}\norm{\vec{\cmd}}_{\infty}}{127\norm{\vec{\cmd}}} \norm{\texttt{wishvel}},
\end{align*}
when $\fmove = 127$, $\rmove = 0$ and $\umove = 0$, then $s = 320$ like in the previous section.

Air:
\begin{align}
\nonumber
\norm*{\projmat{a} \vec{\flat{v}}_f} + \norm*{\vec{\flat{a}}} &= s \norm*{\uvec{\flat{a}}},\\
\nonumber
\vec{v}_{f}^T\texttt{wishdir} + \texttt{accel}T\texttt{wishspeed} &= \texttt{wishspeed}\norm{wishdir},\\
\nonumber
\norm*{\vec{\flat{v}}_f} \cos{\delta_{\opt}} + \texttt{accel}T\texttt{wishspeed} &= \texttt{wishspeed},\\
\nonumber
\flat{v}_f \cos{\delta_{\opt}} &= \texttt{wishspeed} - \texttt{accel}T\texttt{wishspeed},\\
\delta_{\opt} &= \acos\left( \frac{\texttt{wishspeed} \left(1 - \texttt{accel}T\right)}{\flat{v}_f} \right).
\end{align}

\texttt{PM\_Accelerate (wishdir, wishspeed, pm\_airaccelerate);}

The strafe keys in CPM do not ever affect upmove. Not true


\subsection{Upmove effect on acceleration}
\label{sec:upmove}
\codeFromFile{firstline=615,lastline=634,gobble=1}{code/game/bg_pmove.c}
From the above code listing, the current velocity is projected down to the $xy$-plane, is normalized, and then a scale factor is applied forming \texttt{wishspeed} ($s$).
This scale factor is determined by the below code.
\codeFromFile{firstline=306,lastline=308,gobble=1}{code/game/bg_pmove.c}
Hence upmove increases the denominator of the scale factor, decreasing \texttt{wishspeed}.\\
If the player is holding 3 movement keys, ($\fmove$, $\rmove$ and $\umove$), this transformation scales it by a factor of $\frac{\sqrt{2}}{\sqrt{3}}$.
If the player is holding 2 movement keys, ($\fmove$ and $\umove$ or $\rmove$ and $\umove$), the scale factor is $\frac{\sqrt{2}}{2}$.

Hence, the snap zones will change along with all CGazHUD $\delta$ angles, which explains the altered acceleration while holding moveup or movedown.
Also, holding 2 movement keys reduces $\texttt{wishspeed}$ moreso than holding 3 movement keys, decreasing acceleration more\footnote{Thus, although insignificant, full-beat VQ3 strafing is superior to half-beat and moreso to invert.}.


\subsection{Frame rate dependency}
\label{sec:framerate}
We can define \emph{frame rate dependency} as attributes of the game engine that act differently depending on frame rate,
and say that an attribute of the game engine has \emph{frame independency} if the time between frames does not need to be equidistant for the physics to act the same.\\

Given that acceleration is impacted directly by frame rate (by $\flat{a} = sAT$), frame rate has a large impact on speed gains from strafing.\\
TODO: frame rate effect on strafing\\

Additionally, $T$ is floored to the nearest millisecond (0.001), giving us proper-T $T_p$, and frames are delayed until $1000T_p$ milliseconds pass.
For example, with frame rate $\qty{140}{fps}$, $T$ would be floored from $1/140 = 0.007143$ to 0.007. Note: \texttt{minMsec} is an int.
\codeFromFile{firstline=2686,lastline=2690,gobble=1}{code/qcommon/common.c}
\codeFromFile{firstline=2599,lastline=2625,gobble=1}{code/qcommon/common.c}
Hence,
\begin{align*}
T_p &= \min\left(5, \max\left(0.001, \frac{\floor{1000T}}{1000} \right) \right), &&\text{when running a dedicated server or client of a remote server}\\
T_p &= \min\left(0.2, \max\left(0.001, \frac{\floor{1000T}}{1000} \right) \right), &&\text{otherwise.}
\end{align*}
Also, frame rate impacts vertical ($z$-axis) velocity when in air, shown by
\begin{align*}
r_z &= v_z - gT_p\ &&\ldots\ g = 800,\\
\round{r_z} &= v_z - \round*{gT_p}\ &&\ldots\ v_z = \round{v_z}\ \text{when in air}
\end{align*}
Hence, with $T = 1/125 = T_p$,
\begin{align*}
r_z &= v_z - 6.4,\\
\round{r_z} &= v_z - 6,
\end{align*}
and thus over one second $v_z$ is reduced by $\qty{750}{ups}$ instead of $\qty{800}{ups}$, allowing the player to jump higher and hence further.
As a general rule, if effective-gravity $\frac{\round*{gT_p}}{T_p} < 800$ then frame rates given by $\frac{1}{T}$ allow the player to jump higher than intended.
This is expanded upon in Section \ref{sec:x_z} (TODO).\\

Another important point to note is that accelerations on one axis $a_n$ can be rounded to 0 if $a_n\le 0.5$.
This ironically places limits on the functionality of the movement physics at high frame rates, as accelerations will be more frequently nulled.

% TODO: Also need to find out what happens in a situation where the flooring to T_p causes the game to try to render more frames per second than FPS(does it?)
% Eg. 120 FPS. int minMsec = 1000 / 120 = 8.3333, floors to 8. However, T=8 implies 125 frames rendered per second, yet we only have 120 FPS.

Frame rate dependency with respect to overbounces is covered in Section \ref{sec:overbounce} (TODO).


\subsection{Approach to $z$-axis translations}
\label{sec:x_z}
The game engine applies vertical velocity in a slightly unintuitive way in order to make all $z$-axis position translations frame independent.
In regards to the $z$-axis, new velocity is calculated using acceleration, velocity is to player position, and then velocity is snapped.
However the key here is \emph{how} velocity is applied to the player position, demonstrated in \eqref{eq:x_zk+1}.

\begin{align*}
\text{Defining }&v_{z,k}\text{ as the sequence of $z$-axis velocities after snapping after $k$ frames}\\
\text{and }&x_{z,k}\text{ as the sequence of the player's $z$-axis position after $k$ frames},
\end{align*}
\begin{align}
\label{eq:v_zk+1}
v_{z,k+1} &= v_{z,k} - \round*{gT_p}\\
\label{eq:x_zk+1}
x_{z,k+1} &= x_{z,k} + \left(v_{z,k} - \frac{gT_p}{2} \right) T_p
\end{align}
\begin{align}
\nonumber
v_{z,1} &= v_{z,0} - \round*{gT_p}\\\nonumber
v_{z,2} &= v_{z,1} - \round*{gT_p}\\\nonumber
&= v_{z,0} - 2\round*{gT_p}\\
\label{eq:v_zk}
\therefore\ v_{z,k} &= v_{z,0} - k\round*{gT_p}.
\end{align}
Same approach is used to derive $x_{z,k}$, done in Appendix \ref{app:derive_x_zk}, yielding
\begin{align}
\label{eq:x_zk}
x_{z,k} &= x_{z,0} + k\left(v_{z,0} + \frac{\round*{gT_p} - gT_p}{2} \right) T_p - \frac{k^2}{2} \round*{gT_p} T_p\\\nonumber
&= x_{z,0} + kT_p\left(v_{z,0} + \frac{(1 - k)\round*{gT_p} - gT_p}{2} \right).
\end{align}

To solve for the frame $n_{peak}$ that you reach the peak, differentiate $x_{z,k}$.
\begin{align}
\nonumber
x_{z,k}' &= \left(v_{z,0} + \frac{\round*{gT_p} - gT_p}{2} \right) T_p - k\round*{gT_p} T_p\\\nonumber
0 &= \left(v_{z,0} + \frac{\round*{gT_p} - gT_p}{2} \right) T_p - k\round*{gT_p} T_p\\\nonumber
\implies k &= \frac{v_{z,0} - \frac{gT_p}{2} + \frac{\round*{gT_p}}{2}}{\round*{gT_p}}\\\nonumber
&= \frac{v_{z,0} - \frac{gT_p}{2}}{\round*{gT_p}} + \frac{1}{2}\\\nonumber
\implies n_{peak} &= \round*{\frac{v_{z,0} - \frac{gT_p}{2}}{\round*{gT_p}} + \frac{1}{2}}\\
\therefore\ n_{peak} &= \ceil*{\frac{v_{z,0} - \frac{gT_p}{2}}{\round*{gT_p}}}
\end{align}
With $\qty{125}{fps}$ and jump velocity $v_{z,0} = \qty{270}{ups}$, the peak is reached after $n_{peak} = \qty{45}{frames}$.\\

The maximum height the player reaches in a jump is given by substituting $n_{peak}$ into $x_{z,k}$, with $x_{z,0} = 0$.
When step-up is introduced in Section \ref{sec:stepup} this formula changes.
\begin{align}
\label{eq:max_jump_height}
\ceil*{\frac{v_{z,0} - \frac{gT_p}{2}}{\round*{gT_p}}}\left(v_{z,0} + \frac{\round*{gT_p} - gT_p}{2} \right) T_p - \frac{1}{2}\ceil*{\frac{v_{z,0} - \frac{gT_p}{2}}{\round*{gT_p}}}^2 \round*{gT_p} T_p
\end{align}
\\
This implementation of $z$-axis translations is frame independent, as shown below.
\begin{align*}
v_{z,k} = v_{z,0} - k\round*{gT_p}\ \ldots\ \eqref{eq:v_zk}
\end{align*}
Using trapezoidal rule,
\begin{align*}
&\sum_{i=0}^{k-1} \left(\left(v_{z,0} - i\round*{gT_p} \right) + \left(v_{z,0} - (i + 1) \round*{gT_p} \right)\right) \frac{T_p}{2}\\
&\sum_{i=0}^{k-1} \left(v_{z,0} - \left(i + \frac{1}{2} \right) \round*{gT_p} \right) T_p\\
&\implies x_{z,k} = x_{z,0} + k v_{z,0} T_p - \frac{k^2}{2}\round*{gT_p} T_p,
\end{align*}
but $x_{z,k}$ is
\begin{align*}
x_{z,0} + k\left(v_{z,0} + \frac{\round*{gT_p} - gT_p}{2} \right) T_p - \frac{k^2}{2}\round*{gT_p} T_p\ \ldots\ \eqref{eq:x_zk}.
\end{align*}
Using inverse trapezoidal rule,
\begin{align}
\nonumber
&\sum_{i=0}^{k-1} \left(\left(v_{z,0} + \frac{\round*{gT_p} - gT_p}{2} \right) - \left(i + \frac{1}{2} \right) \round*{gT_p} \right) T_p\\\nonumber
&\sum_{i=0}^{k-1} \left(\left(\left(v_{z,0} + \frac{\round*{gT_p} - gT_p}{2} \right) - i\round*{gT_p} \right) + \left(\left(v_{z,0} + \frac{\round*{gT_p} - gT_p}{2} \right) - (i + 1)\round*{gT_p} \right) \right) \frac{T_p}{2}\\
\label{eq:corrected_v_zk}
&\implies v_{z,k} = \left(v_{z,0} + \frac{\round*{gT_p} - gT_p}{2} \right) - k\round*{gT_p}
\end{align}
Thus, $z$-axis position is updated using this ``corrected'' velocity, meaning $z$-axis translations are frame independent, since a fractional $k$ would still result in the correct change in position. Hence $k \in \symbb{R}^+$.\\

As $x_z$ is updated using ``corrected'' velocity \eqref{eq:corrected_v_zk} rather than \eqref{eq:v_zk}, the difference in applied velocity is
\begin{align*}
\eqref{eq:corrected_v_zk} - \eqref{eq:v_zk} &= v_{z,0} + \frac{\round*{gT_p} - gT_p}{2} - k\round*{gT_p} - v_{z,0} + k\round*{gT_p}\\
&= \frac{\round*{gT_p} - gT_p}{2}.
\end{align*}
%Hence, in terms of $x_z$ translations, there is an initial velocity of $v_{z,0} + \frac{\round*{gT_p} - gT_p}{2}$ rather than $v_{z,0}$.
This implementation results in a height ``error'' $h$, given by
\begin{align}
\label{eq:height_error}
h = n_{gravity}T_p\frac{\round*{gT_p} - gT_p}{2}\ \ldots\ \text{where $n_{gravity} \in \symbb{R}^+$ is the number of frames that gravity was applied}.
\end{align}
For example, a jump at $\qty{125}{fps}$ lasts $n_{gravity} = \qty{90}{frames}$, so the final $x_z$ of the player is $h = \qty{-0.144}{units}$ relative to the starting $x_z$\footnote{Since $h < 0$ the final position is below the starting position, assuming the player didn't clip into the ground plane.}.\\

As a side note, this implementation of $z$-axis translations is also frame rate independent $\Longleftrightarrow$ rounding is ignored, since
\begin{itemize}
\item
Vertical acceleration is linear (constant) and thus
\item
Ignoring rounding,
\begin{align*}
x_{z,k} &= x_{z,0} + k\left(v_{z,0} + \frac{gT_p - gT_p}{2} \right) T_p - \frac{k^2}{2} gT_p T_p\\
&= x_{z,0} + kv_{z,0} T_p - \frac{k^2 g{T_p}^2}{2}\\
&= x_{z,0} + \left(kT_p \right) v_{z,0} - \frac{\left(kT_p \right)^2 g}{2},
\end{align*}
which is the same as the physical model equation.
Without ignoring rounding, the implementation is frame rate dependent, hence the differing jump heights by changing frame rate.
\end{itemize}

It can be shown that $T_p = 0.003$ results in the largest jump height, with effective-gravity of $666.\overline{6}$.\\
TODO


\subsection{Step-up}
\label{sec:stepup}
TODO: explanation of step-up, conditions, special cases (if any)\\

The maximum height the player can step-up is $\qty{18}{units}$.
Hence, to calculate the maximum height the player can jump including step-up, add $\qty{18}{units}$ to \eqref{eq:max_jump_height} giving
\begin{align}
\label{eq:max_jump_height_stepup}
\ceil*{\frac{v_{z,0} - \frac{gT_p}{2}}{\round*{gT_p}}}\left(v_{z,0} + \frac{\round*{gT_p} - gT_p}{2} \right) T_p - \frac{1}{2}\ceil*{\frac{v_{z,0} - \frac{gT_p}{2}}{\round*{gT_p}}}^2 \round*{gT_p} T_p + 18,
\end{align}
which is $\qty{66.528}{units}$ at $\qty{125}{fps}$.
%STEPSIZE defined in bg_local.h


\subsection{Skimming}
\label{sec:skimming}
TODO


\subsection{Overbounces}
\label{sec:overbounce}
TODO%\\
%Overbounces occur when $x_z$ comes within 0 and 0.25 units of a ground plane.


\subsection{Wallbug}
\label{sec:wallbug}
Wallbugs occur due to $z$-axis velocity being zeroed when the game thinks the player entity is inside a solid when they actually aren't.
Zeroing the $z$-axis velocity causes the player to stop falling, but still be able to accelerate by strafing along the $xy$-plane.
\codeFromFile{firstline=99,lastline=103,gobble=2}{code/game/bg_slidemove.c}
TODO: escape conditions
